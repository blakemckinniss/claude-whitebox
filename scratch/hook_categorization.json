{
  "confidence_init.py": {
    "category": "CRITICAL_STATE",
    "reason": "Initializes session state, modifies confidence.json",
    "convertible": false
  },
  "command_tracker.py": {
    "category": "CRITICAL_STATE",
    "reason": "Tracks command execution for prerequisite enforcement",
    "convertible": false
  },
  "evidence_tracker.py": {
    "category": "CRITICAL_STATE",
    "reason": "Records evidence gathering for confidence calculation",
    "convertible": false
  },
  "detect_confidence_penalty.py": {
    "category": "CRITICAL_STATE",
    "reason": "Applies penalties to confidence state",
    "convertible": false
  },
  "detect_confidence_reward.py": {
    "category": "CRITICAL_STATE",
    "reason": "Applies rewards to confidence state",
    "convertible": false
  },
  "pre_advice.py": {
    "category": "CRITICAL_GATE",
    "reason": "Hard block for strategic advice without evidence",
    "convertible": false
  },
  "tier_gate.py": {
    "category": "CRITICAL_GATE",
    "reason": "Hard block for tier violations",
    "convertible": false
  },
  "confidence_gate.py": {
    "category": "CRITICAL_GATE",
    "reason": "Hard block for confidence violations",
    "convertible": false
  },
  "command_prerequisite_gate.py": {
    "category": "CRITICAL_GATE",
    "reason": "Hard block for prerequisite violations",
    "convertible": false
  },
  "risk_gate.py": {
    "category": "CRITICAL_GATE",
    "reason": "Hard block for risky operations",
    "convertible": false
  },
  "pre_write_audit.py": {
    "category": "CRITICAL_GATE",
    "reason": "Security/stub detection with deterministic rules",
    "convertible": false
  },
  "ban_stubs.py": {
    "category": "CRITICAL_GATE",
    "reason": "Prevents stub code with regex patterns",
    "convertible": false
  },
  "block_mcp.py": {
    "category": "CRITICAL_GATE",
    "reason": "Whitebox enforcement (no MCP tools)",
    "convertible": false
  },
  "synapse_fire.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Pattern matching + file search + random constraints",
    "convertible": false
  },
  "session_init.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Session initialization with file operations",
    "convertible": false
  },
  "auto_commit_on_complete.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Git operations with state tracking",
    "convertible": false
  },
  "auto_commit_on_end.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Git operations on session end",
    "convertible": false
  },
  "auto_remember.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Memory extraction with file writes",
    "convertible": false
  },
  "session_digest.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Digest generation with file operations",
    "convertible": false
  },
  "token_tracker.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Token estimation with transcript parsing",
    "convertible": false
  },
  "debt_tracker.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Technical debt tracking with file operations",
    "convertible": false
  },
  "pattern_detector.py": {
    "category": "COMPLEX_LOGIC",
    "reason": "Multi-pattern detection with state updates",
    "convertible": false
  },
  "detect_batch.py": {
    "category": "ADVISORY_SIMPLE",
    "reason": "Simple keyword matching \u2192 LLM can understand batch intent",
    "convertible": true,
    "prompt_template": "Analyze if this describes a batch operation: $ARGUMENTS\n\nCheck for:\n- Keywords: batch, bulk, mass, \"all files\", iterate, loop\n- Patterns: \"process files\", \"download all\", \"convert all\"\n\nIf batch operation detected:\n{\n  \"decision\": \"approve\",\n  \"systemMessage\": \"\u26a0\ufe0f BATCH OPERATION DETECTED\\nUse scripts.lib.parallel for multi-threading\\nExample: run_parallel(func, items, max_workers=10)\"\n}\n\nOtherwise: {\"decision\": \"approve\"}"
  },
  "check_knowledge.py": {
    "category": "ADVISORY_SIMPLE",
    "reason": "Fast-moving tech detection \u2192 LLM can assess freshness needs",
    "convertible": true,
    "prompt_template": "Evaluate if this requires current documentation: $ARGUMENTS\n\nCheck for:\n- Topics about new libraries, APIs, frameworks\n- Error debugging that needs current solutions\n- \"Latest\", \"current\", \"how to\" patterns\n\nIf research needed:\n{\n  \"decision\": \"approve\",\n  \"systemMessage\": \"\u26a0\ufe0f KNOWLEDGE CHECK: Run /research first\\nTraining data is from Jan 2025 - APIs may have changed\"\n}"
  },
  "sanity_check.py": {
    "category": "ADVISORY_SIMPLE",
    "reason": "Library + code intent detection \u2192 LLM understands this naturally",
    "convertible": true,
    "prompt_template": "Check if user wants to write code for complex libraries: $ARGUMENTS\n\nIf coding with pandas/boto3/fastapi/etc without probing:\n{\n  \"decision\": \"approve\",\n  \"systemMessage\": \"\u26a0\ufe0f SANITY CHECK: Run /probe and /research before coding\\nDo not guess API signatures\"\n}"
  },
  "force_playwright.py": {
    "category": "ADVISORY_SIMPLE",
    "reason": "UI automation detection \u2192 LLM can recognize browser needs",
    "convertible": true,
    "prompt_template": "Check if this requires browser automation: $ARGUMENTS\n\nUI triggers: click, login, screenshot, dynamic content, JavaScript\nLazy triggers: requests, BeautifulSoup\n\nIf UI task + lazy approach:\n{\n  \"decision\": \"approve\",\n  \"systemMessage\": \"\u26a0\ufe0f Use Playwright for browser automation\\nrequests/BS4 fails on dynamic sites\"\n}"
  },
  "intervention.py": {
    "category": "ADVISORY_SIMPLE",
    "reason": "Bikeshedding detection \u2192 LLM can assess value/ROI",
    "convertible": true,
    "prompt_template": "Detect bikeshedding/YAGNI/NIH syndrome: $ARGUMENTS\n\nBikeshedding: prettier config, linting, color schemes\nNIH: \"build our own\", \"custom framework\"\nYAGNI: \"might need\", \"future proof\"\n\nIf detected:\n{\n  \"decision\": \"approve\",\n  \"systemMessage\": \"\u2696\ufe0f JUDGE WARNING: Run /judge before proceeding\\nDoes this ship to production TODAY?\"\n}"
  },
  "anti_sycophant.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Opinion request detection + assumption extraction",
    "convertible": true
  },
  "detect_gaslight.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Frustration detection + sherlock invocation",
    "convertible": true
  },
  "detect_low_confidence.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Confidence threshold checks",
    "convertible": false
  },
  "enforce_workflow.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Workflow enforcement reminders",
    "convertible": true
  },
  "prerequisite_checker.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Multi-condition prerequisite checks",
    "convertible": false
  },
  "best_practice_enforcer.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Best practice reminders",
    "convertible": true
  },
  "ecosystem_mapper.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Ecosystem thinking reminders",
    "convertible": true
  },
  "intent_classifier.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Intent classification for routing",
    "convertible": true
  },
  "command_suggester.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Suggests next commands based on context",
    "convertible": true
  },
  "post_tool_command_suggester.py": {
    "category": "ADVISORY_COMPLEX",
    "reason": "Post-tool command suggestions",
    "convertible": true
  },
  "trigger_skeptic.py": {
    "category": "DEPRECATED",
    "reason": "PreToolUse skeptic trigger (likely unused now)",
    "convertible": false
  },
  "absurdity_detector.py": {
    "category": "DEPRECATED",
    "reason": "Possibly experimental",
    "convertible": false
  },
  "pre_delegation.py": {
    "category": "GATE",
    "reason": "Agent delegation checks",
    "convertible": false
  }
}