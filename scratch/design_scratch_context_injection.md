# Scratch Context Injection System Design

## Goal
Transform scratch/ from passive workspace â†’ active associative memory layer
Inject relevant past work as "semantic clues" to ground current decisions

## Components

### 1. Scratch Indexer (AST + Regex)
```python
# Extract semantic signatures from scratch/
- Functions/classes (AST)
- Key decisions (regex: "VERDICT:", "SOLUTION:", "ROOT CAUSE:")
- Test patterns (regex: "def test_", "assert", "pytest")
- Design rationale (from .md files)
```

### 2. Association Engine
```python
# Match current prompt â†’ past work
def find_associations(prompt):
    - Keyword overlap (TF-IDF)
    - Structural similarity (same tools/patterns)
    - Problem domain (auth, API, testing, etc.)
    - Failure patterns (error types, stack traces)
```

### 3. Context Injector Hook (UserPromptSubmit)
```python
# Inject top N associations as context
Output format:
"ðŸ“‚ SCRATCH CONTEXT (Past Work):
  - scratch/test_enforcement.py: Similar hook testing pattern
  - scratch/oracle_analysis.md: Previous decision on external LLMs
  - scratch/epistemology_expanded.py: Confidence system iteration
"
```

### 4. Promotion Detector
```python
# Surface reusable patterns
If script used >3 times across sessions:
  â†’ Suggest promotion to scripts/
```

## Benefits
1. **Grounding**: LLM sees actual past implementations, not just memory
2. **Pattern Reuse**: Avoid rebuilding solved problems
3. **Consistency**: Reference past decisions for similar problems
4. **Learning**: Failures in test_*.py become lessons
5. **Neural Links**: Associative retrieval mimics human memory

## Implementation Phases

### Phase 1: Basic Indexer
- Scan scratch/ for .py, .md files
- Extract function names (AST), key phrases (regex)
- Store in .claude/memory/scratch_index.json

### Phase 2: Keyword Association
- Match user prompt keywords â†’ scratch file keywords
- Inject top 3 matches as context

### Phase 3: Structural Association (AST)
- Detect similar code patterns (e.g., both use parallel.py)
- Inject: "You previously solved X with Y pattern"

### Phase 4: Failure Learning
- Extract assertions/tests from test_*.py
- Inject: "Past tests caught: [edge cases]"

### Phase 5: Design Rationale Injection
- Parse .md files for decisions (VERDICT, RECOMMENDATION)
- Inject: "Previous analysis of similar problem: [summary]"

## Edge Cases
- Don't inject stale/wrong solutions (check file age + git status)
- Cap context at ~500 tokens (top 3-5 associations max)
- Filter by relevance score (TF-IDF cosine similarity >0.3)

## Integration Points
- Hook: .claude/hooks/scratch_associator.py (UserPromptSubmit)
- Index: .claude/memory/scratch_index.json (regenerated by upkeep.py)
- Config: .claude/config/scratch_association.json (thresholds, limits)
